/***
 *  $Id$
 **
 *  File: a7.cpp
 *  Created: Apr 17, 2015
 *
 *  Author: Jaroslaw Zola <jzola@buffalo.edu>
 *  Copyright (c) 2015 Jaroslaw Zola
 */

// *** DO NOT EDIT THIS FILE ***

#include "symbol.hpp"
#include "a7.hpp"

#include <fstream>
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>


template <typename IterIn, typename IterOut>
void symbols(IterIn first, IterIn last, IterOut out) {
    std::vector<int> count(256, 0);

    for (; first != last; ++first) {
        const std::string& s = *first;
        for (int i = 0; i < s.size(); ++i) count[s[i]]++;
    } // for first

    for (int c = 0; c < 256; ++c) {
        if (count[c] > 0) *out++ = symbol(static_cast<char>(c), count[c]);
    }
} // symbols


void print_dictionary(std::ostream& os, const bnode<symbol>* root, std::string& s) {
    if ((root->left == 0) && (root->right == 0)) {
        os << root->value.value << " " << s << std::endl;
        return;
    } else if ((root->left == 0) || (root->right == 0)) {
        std::cout << "incorrect tree" << std::endl;
        throw std::runtime_error("incorrect tree");
    }

    // visit left '0' path
    s.push_back('0');
    print_dictionary(os, root->left, s);
    s.resize(s.size() - 1);

    // visit right '1' path
    s.push_back('1');
    print_dictionary(os, root->right, s);
    s.resize(s.size() - 1);
} // print_dictionary

inline void print_dictionary(std::ostream& os, const bnode<symbol>* root) {
    std::string s;
    print_dictionary(os, root, s);
} // print_dictionary


int main(int argc, char* argv[]) {
    if (argc != 2) {
        std::cout << "usage: ./a7 file" << std::endl;
        return -1;
    }

    // get input text
    std::ifstream f(argv[1]);

    std::string s;
    std::vector<std::string> lines;

    while (!f.eof()) {
        s = "";
        std::getline(f, s);
        if (!s.empty()) lines.push_back(s);
    }

    f.close();

    // create a list of symbols
    std::vector<symbol> A;
    symbols(lines.begin(), lines.end(), std::back_inserter(A));

    // process the list (student's code)
    bnode<symbol>* tree = huffman_tree(A.begin(), A.end());

    // print dictionary
    print_dictionary(std::cout, tree);

    // free memory (student's code)
    release_tree(tree);

    return 0;
} // main
